import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as t}from"./app-B37NkK81.js";const p={};function e(l,s){return t(),a("div",null,s[0]||(s[0]=[n(`<h5 id="_1-下面论述正确的是" tabindex="-1"><a class="header-anchor" href="#_1-下面论述正确的是"><span>1. 下面论述正确的是（）？</span></a></h5><p>A. 如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值</p><p>B. 如果a,b的hashcode相同，那么a.equals(b)必须返回true</p><p>C. 对于一个类，其所有对象的hashcode必须不同</p><p>D. 如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同</p><p><strong>正确答案：D 你的答案：B</strong></p><p>hashCode方法本质就是一个哈希函数，这是Object类的作者说明的。Object类的作者在注释的最后一段的括号中写道：将对象的地址值映射为integer类型的哈希值。但hashCode()并不完全可靠的，有时候不同的对象他们生成的hashcode也会一样，因此hashCode()只能说是大部分时候可靠。</p><p>因此我们也需要重写equals()方法，但因为重写的equals()比较全面比较复杂，会造成程序效率低下，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。因此，正常的操作流程是先用hashCode()去对比两个对象，如果hashCode()不一样，则表示这两个对象肯定不相等，直接返回false,如果hashCode()相同，再对比他们的equals()。</p><p>综上所述：</p><p>equals()相等的两个对象hashCode()一定相等。hashCode()相等的两个对象equal()不一定相等。</p><p>因此选项D正确。</p><h5 id="_2-下面哪一项不是加载驱动程序的方法" tabindex="-1"><a class="header-anchor" href="#_2-下面哪一项不是加载驱动程序的方法"><span>2. 下面哪一项不是加载驱动程序的方法？</span></a></h5><p>A. 通过DriverManager.getConnection方法加载</p><p>B. 调用方法 Class.forName</p><p>C. 通过添加系统的jdbc.drivers属性</p><p>D. 通过registerDriver方法注册</p><p><strong>正确答案：A 你的答案：B</strong></p><p>DriverManager.getConnection方法返回一个Connection对象，这是加载驱动之后才能进行的</p><h5 id="_3-下面哪些选项是正确的" tabindex="-1"><a class="header-anchor" href="#_3-下面哪些选项是正确的"><span>3. 下面哪些选项是正确的（）</span></a></h5><p>A. &gt;&gt;是算术右移操作符</p><p>B. &gt;&gt;是逻辑右移操作符</p><p>C. &gt;&gt;&gt;是算术右移操作符</p><p>D. &gt;&gt;&gt;是逻辑右移操作符</p><p><strong>正确答案：AD 你的答案：BC</strong></p><p>Java中：</p><ul><li><code>&lt;&lt;</code>：算术左移。</li><li><code>&gt;&gt;</code>：算术右移。</li><li><code>&gt;&gt;&gt;</code>：逻辑右移。</li></ul><p>【注】没有<code>&lt;&lt;&lt;</code>符号。</p><h5 id="_4-javaweb中有一个类-当会话种绑定了属性或者删除了属性时-他会得到通知-这个类是" tabindex="-1"><a class="header-anchor" href="#_4-javaweb中有一个类-当会话种绑定了属性或者删除了属性时-他会得到通知-这个类是"><span>4. JavaWEB中有一个类，当会话种绑定了属性或者删除了属性时，他会得到通知，这个类是：( )</span></a></h5><p>A. HttpSessionAttributeListener</p><p>B. HttpSessionBindingListener</p><p>C. HttpSessionObjectListener</p><p>D. HttpSessionListener;</p><p>E. HttpSession</p><p>F. HttpSessionActivationListener</p><p><strong>正确答案：A 你的答案：B</strong></p><p><strong>HttpSessionAttributeListener</strong>：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；</p><p><strong>HttpSessionBindingListener</strong>：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；</p><p><strong>HttpSessionObjectListener</strong>：没有该接口API；</p><p><strong>HttpSessionListener</strong>：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；</p><p><strong>HttpSessionActivationListener</strong>：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p><h5 id="_5-在java中重写方法应遵循规则的包括" tabindex="-1"><a class="header-anchor" href="#_5-在java中重写方法应遵循规则的包括"><span>5.在java中重写方法应遵循规则的包括（）</span></a></h5><p>A. 访问修饰符的限制一定要大于被重写方法的访问修饰符</p><p>B. 可以有不同的访问修饰符</p><p>C. 参数列表必须完全与被重写的方法相同</p><p>D. 必须具有不同的参数列表</p><p><strong>正确答案：BC 你的答案：BD</strong></p><p>总结来说为：</p><ul><li>方法名相同，参数类型相同</li><li>子类返回类型等于父类方法返回类型，</li><li>子类抛出异常小于等于父类方法抛出异常</li><li>子类访问权限大于等于父类方法访问权限。</li></ul><p>详细的说明为：</p><p><strong>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</strong> <strong>即外壳不变，核心重写！</strong></p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。</p><p><strong>方法的重写规则</strong></p><ul><li>1）参数列表必须完全与被重写方法的相同；</li><li>2）返回类型必须完全与被重写方法的返回类型相同；</li><li>3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>4）父类的成员方法只能被它的子类重写。</li><li>5）声明为final的方法不能被重写。</li><li>6）声明为static的方法不能被重写，但是能够被再次声明。</li><li>7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>10）构造方法不能被重写。</li><li>11）如果不能继承一个方法，则不能重写这个方法。</li></ul><h5 id="_6-一个容器类数据结构-读写平均-使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能-最好的办法是-。" tabindex="-1"><a class="header-anchor" href="#_6-一个容器类数据结构-读写平均-使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能-最好的办法是-。"><span>6.一个容器类数据结构，读写平均，使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能，最好的办法是______。</span></a></h5><p>A. 只对写操作加锁，不对读操作加锁</p><p>B. 读操作不加锁，采用copyOnWrite的方式实现写操作</p><p>C. 分区段加锁</p><p>D. 无法做到</p><p><strong>正确答案：C 你的答案：A</strong></p><p>参考答案：答案：C</p><ul><li>A，只对写操作加锁，不对读操作加锁，会造成读到脏数据</li><li>B，CopyOnWrite的核心思想是利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用。这里读写平均，不适用</li><li>C，分段加锁，只在影响读写的地方加锁，锁可以用读写锁，可以提高效率</li></ul><h5 id="_7-以下哪些jvm的垃圾回收方式采用的是复制算法回收" tabindex="-1"><a class="header-anchor" href="#_7-以下哪些jvm的垃圾回收方式采用的是复制算法回收"><span>7.以下哪些jvm的垃圾回收方式采用的是复制算法回收?</span></a></h5><p>A. 新生代串行收集器</p><p>B. 老年代串行收集器</p><p>C. 并行收集器</p><p>D. 新生代并行回收收集器</p><p>E. 老年代并行回收收集器</p><p>F. cms收集器</p><p><strong>正确答案：AD 你的答案：ACEF</strong></p><p>Serial New收集器是针对新生代的收集器，采用的是复制算法</p><p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p><p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p><p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p><p>Parallel Old（并行）收集器，针对老年代，标记整理</p><p>CMS收集器，基于标记清理</p><p>G1收集器：整体上是基于标记整理 ，局部采用复制</p><p>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</p><h5 id="_8-关于下面一段代码-以下说法正确的是" tabindex="-1"><a class="header-anchor" href="#_8-关于下面一段代码-以下说法正确的是"><span>8.关于下面一段代码，以下说法正确的是： ()</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A. 同一个对象，分别调用方法a和b，锁住的是同一个对象</p><p>B. 同一个对象，分别调用方法a和c，锁住的是同一个对象</p><p>C. 同一个对象，分别调用方法b和c，锁住的不是同一个对象</p><p>D. 同一个对象，分别调用方法a、b、c，锁住的不是同一个对象</p><p><strong>正确答案：AC 你的答案：AB</strong></p><p>修饰非静态方法 锁的是this 对象</p><p>修饰静态方法 锁的是class对象</p><h5 id="_9-java的daemon线程-setdaemon-设置必须要" tabindex="-1"><a class="header-anchor" href="#_9-java的daemon线程-setdaemon-设置必须要"><span>9.Java的Daemon线程，setDaemon( )设置必须要？</span></a></h5><p>A. 在start之前</p><p>B. 在start之后</p><p>C. 前后都可以</p><p><strong>正确答案：A 你的答案：B</strong></p><p><strong>setDaemon()方法必须在线程启动之前调用，当线程正在运行时调用会产生异常。</strong></p><p><strong>java的线程分为两类: 用户线程和daemon线程</strong></p><ul><li>用户线程: 用户线程可以简单的理解为用户定义的线程,当然包括main线程(以前我错误的认为main线程也是一个daemon线程,但是慢慢的发现原来main线程不是,因为如果我再main线程中创建一个用户线程,并且打出日志,我们会发现这样一个问题,main线程运行结束了,但是我们的线程任然在运行).</li><li>daemon线程: daemon线程是为我们创建的用户线程提供服务的线程,比如说jvm的GC等等,这样的线程有一个非常明显的特征: 当用户线程运行结束的时候,daemon线程将会自动退出.(由此我们可以推出下面关于daemon线程的几条基本特点)</li></ul><p><strong>daemon 线程的特点:</strong></p><ul><li><p>守护线程创建的过程中需要先调用setDaemon方法进行设置,然后再启动线程.否则会报出IllegalThreadStateException异常.(个人在想一个问题,为什么不能动态更改线程为daemon线程?有时间一个补上这个内容,现在给出一个猜测: 是因为jvm判断线程状态的时候,如果当前只存在一个线程Thread1,如果我们把这个线程动态更改为daemon线程,jvm会认为当前已经不存在用户线程而退出,稍后将会给出正确结论,抱歉!如果有哪位大牛看到,希望给出指点,谢谢!)</p></li><li><p>由于daemon线程的终止条件是当前是否存在用户线程,所以我们不能指派daemon线程来进行一些业务操作,而只能服务用户线程.</p></li><li><p>daemon线程创建的子线程任然是daemon线程.</p></li></ul><h5 id="_10-关于string、stringbuffer、stringbuilder以下说法错误的是" tabindex="-1"><a class="header-anchor" href="#_10-关于string、stringbuffer、stringbuilder以下说法错误的是"><span>10.关于String、StringBuffer、StringBuilder以下说法错误的是</span></a></h5><p>A. StringBuilder运行速度最快</p><p>B. StringBuffer是线程安全的</p><p>C. String的值是可变的</p><p>D. StringBuffer运行速度比String快</p><p><strong>正确答案：C</strong></p><p>String是final修饰的，不可变</p><p>在运行速度上StringBuffer因为兼顾了线程安全，效率不及StringBuilder</p><p>StringBuffer是线程安全的</p><h5 id="_11-对于非运行时异常-程序中一般可不做处理-由java虚拟机自动进行处理。" tabindex="-1"><a class="header-anchor" href="#_11-对于非运行时异常-程序中一般可不做处理-由java虚拟机自动进行处理。"><span>11.对于非运行时异常，程序中一般可不做处理，由java虚拟机自动进行处理。</span></a></h5><p>A. 正确</p><p>B. 错误</p><p><strong>正确答案：B 你的答案：A</strong></p><p>Java异常都继承自类Throwable，Throwable子类有Error和Exception，其中Exception又分为运行时异常和编译时异常。编译时异常是未雨绸缪性质的异常，是防范，需要显示处理。运行时异常是程序员问题造成，并不强制进行显示处理。</p><h5 id="_12-关于匿名内部类叙述正确的是" tabindex="-1"><a class="header-anchor" href="#_12-关于匿名内部类叙述正确的是"><span>12. 关于匿名内部类叙述正确的是？ ( )</span></a></h5><p>A. 匿名内部类可以继承一个基类，不可以实现一个接口</p><p>B. 匿名内部类不可以定义构造器</p><p>C. 匿名内部类不能用于实参</p><p>D. 以上说法都不正确</p><p><strong>正确答案：B</strong></p><p><strong>巧记：由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。</strong></p><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><ul><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><h5 id="_13-当你编译和运行下面的代码时-会出现下面选项中的哪种情况" tabindex="-1"><a class="header-anchor" href="#_13-当你编译和运行下面的代码时-会出现下面选项中的哪种情况"><span>13.当你编译和运行下面的代码时，会出现下面选项中的哪种情况？</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Pvf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> Paddy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Paddy);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A. 编译时错误</p><p>B. 编译通过并输出结果false</p><p>C. 编译通过并输出结果true</p><p>D. 编译通过并输出结果null</p><p><strong>正确答案：B 你的答案：C</strong> 类中声明的变量有默认初始值；方法中声明的变量没有默认初始值，必须在定义时初始化，否则在访问该变量时会出错。</p><p>本题中Paddy是静态的成员变量，因此它会获得<strong>boolean类型的初始值false</strong>。</p><h5 id="_14-给定include1-jsp文件代码片段-如下" tabindex="-1"><a class="header-anchor" href="#_14-给定include1-jsp文件代码片段-如下"><span>14.给定include1.jsp文件代码片段，如下：</span></a></h5><div class="language-jsp line-numbers-mode" data-highlighter="shiki" data-ext="jsp" data-title="jsp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> &lt;% pageContext.setAttribute(“User”,”HAHA”);%&gt;</span></span>
<span class="line"><span>_______________________________// 此处填写代码</span></span>
<span class="line"><span> //给定include2.jsp文件代码片段如下：</span></span>
<span class="line"><span> &lt;%=pageContext.getAttribute(“User”)%&gt;</span></span>
<span class="line"><span> //要求运行include1.jsp时，浏览器上输出：HAHA</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A. &lt;jsp:include page=”include2.jsp” flash=”true”&gt;</p><p>B. &lt;%@include file=”include2.jsp”%&gt;</p><p>C. &lt;jsp:forward page=”include2.jsp”&gt;</p><p>D. &lt;% response.sendRedirect(“include2.jsp”); %&gt;</p><p><strong>正确答案：B 你的答案：A</strong></p><ul><li><p>A选项使用了jsp中动作标签的包含标签，这里是动态包含。原理是包含与被包含的页面单独翻译成不同的java文件，然后运行时合并在一起。因为是存在域中的数据，故刚开始就直接翻译数据还不存在，因此浏览器上不能显示出HAHA。</p></li><li><p>B选项使用了jsp三大指令中的包含指令，这里是静态包含。原理是直接把包含与被包含页面的内容先合并在一起，然后翻译成一个java源文件，最后编译执行。故可以在浏览器上显示出HAHA。</p></li><li><p>C和D选项分别使用了跳转和重定向，我们知道jsp中有四个域对象，从小到大分别为：</p><ul><li>page域：在同一个jsp页面中数据有效</li><li>request域：在同一个请求中数据有效</li><li>session域：在用一个会话中数据有效</li><li>application域：在同一个网站中数据有效</li></ul></li></ul><p>题中使用的是page域对象：pageContext，而C选项应该使用request域对象：HttpServletRequest，而D选项应该至少使用session域对象：HttpSession（如果处于同一会话中）。</p><h5 id="_15-下面对静态数据成员的描述中-正确的是" tabindex="-1"><a class="header-anchor" href="#_15-下面对静态数据成员的描述中-正确的是"><span>15.下面对静态数据成员的描述中，正确的是</span></a></h5><p>A. 静态数据成员可以在类体内进行初始化</p><p>B. 静态数据成员不可以被类的对象调用</p><p>C. 静态数据成员不受private控制符的作用</p><p>D. 静态数据成员可以直接用类名调用</p><p><strong>正确答案：A 你的答案：D</strong></p><p>D选项需要考虑在A类通过类名访问B类的静态成员变量时，B类的静态成员变量必须public修饰</p><h5 id="_16-下面哪些类实现或继承了-collection-接口" tabindex="-1"><a class="header-anchor" href="#_16-下面哪些类实现或继承了-collection-接口"><span>16.下面哪些类实现或继承了 Collection 接口？</span></a></h5><p>A. HashMap</p><p>B. ArrayList</p><p>C. Vector</p><p>D. Iterator</p><p><strong>正确答案：BC 你的答案：ABCD</strong></p><ul><li>Java集合框架主要由Collection和Map两个根接口及其子接口、实现类组成</li><li>collection 的子接口包括List,set,queue</li><li>Map包括三个实现类HashMap，HashTable，LinkeHashMap</li></ul><figure><img src="https://s21.ax1x.com/2024/05/27/pk1VlYF.png" alt="集合结构图" tabindex="0" loading="lazy"><figcaption>集合结构图</figcaption></figure><figure><img src="https://img2.baidu.com/it/u=650402853,3705164043&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=1407&amp;h=500" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="_17-在j2ee中-使用servlet过滤器-需要在web-xml中配置-元素" tabindex="-1"><a class="header-anchor" href="#_17-在j2ee中-使用servlet过滤器-需要在web-xml中配置-元素"><span>17.在J2EE中，使用Servlet过滤器，需要在web.xml中配置（）元素</span></a></h5><p>A. <code>&lt;filter&gt;</code></p><p>B.<code> &lt;filter-mapping&gt;</code></p><p>C. <code>&lt;servlet-filter&gt;</code></p><p>D. <code>&lt;filter-config&gt;</code></p><p><strong>正确答案：AB 你的答案：BC</strong></p><p>Servlet过滤器的配置包括两部分：</p><ul><li>第一部分是过滤器在Web应用中的定义，由<code>&lt;filter&gt;</code>元素表示，包括<code>&lt;filter-name&gt;</code>和<code>&lt;filter-class&gt;</code>两个必需的子元素</li><li>第二部分是过滤器映射的定义，由<code>&lt;filter-mapping&gt;</code>元素表示,可以将一个过滤器映射到一个或者多个Servlet或JSP文件，也可以采用url-pattern将过滤器映射到任意特征的URL。</li></ul><h5 id="_18-下面正确的是" tabindex="-1"><a class="header-anchor" href="#_18-下面正确的是"><span>18.下面正确的是？</span></a></h5><p>A. <code>Statement sta=con.createStatement(); ResultSet rst=sta.executeQuery(&quot;select * from book&quot;);</code></p><p>B. <code>Statement sta=con.createStatement(&quot;select * from book&quot;); ResultSet rst=sta.executeQuery();</code></p><p>C. <code>PreparedStatement pst=con.prepareStatement(); ResultSet rst=pst.executeQuery(&quot;select * from book&quot;);</code></p><p>D. <code>PreparedStatement pst=con.prepareStatement(&quot;select * from book&quot;); ResultSet rst=pst.executeQuery();</code></p><p><strong>正确答案：AD 你的答案：BC</strong></p><p>创建Statement是不传参的，PreparedStatement是需要传入sql语句</p><h5 id="_19-可以把任何一种数据类型的变量赋给object类型的变量。" tabindex="-1"><a class="header-anchor" href="#_19-可以把任何一种数据类型的变量赋给object类型的变量。"><span>19.可以把任何一种数据类型的变量赋给Object类型的变量。</span></a></h5><p>A. 对</p><p>B. 错</p><p><strong>正确答案：A 你的答案：B</strong></p><p>对象类型继承自Object可以赋值；而八大基础数据类型会自动装箱后赋值给Object，所以编译运行都不会报错</p><h5 id="_20-已知如下类定义" tabindex="-1"><a class="header-anchor" href="#_20-已知如下类定义"><span>20.已知如下类定义：</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Base</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Base</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (){ </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Base</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ( </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ){ </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fun</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ){ </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //... </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Child</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Base</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // member methods  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下哪句可以正确地加入子类中？</p><p>A. <code>private void fun( int n ){ //...}</code></p><p>B. <code>void fun ( int n ){ //... }</code></p><p>C. <code>protected void fun ( int n ) { //... }</code></p><p>D. <code>public void fun ( int n ) { //... }</code></p><p><strong>正确答案：A 你的答案：B</strong></p><p><strong>方法的重写（override）两同两小一大原则</strong>：</p><ul><li>方法名相同，参数类型相同</li><li>子类返回类型小于等于父类方法返回类型</li><li>子类抛出异常小于等于父类方法抛出异常</li><li>子类访问权限大于等于父类方法访问权限。</li></ul><h5 id="_21-以下哪个类包含方法flush" tabindex="-1"><a class="header-anchor" href="#_21-以下哪个类包含方法flush"><span>21.以下哪个类包含方法flush()？（）</span></a></h5><p>A. InputStream</p><p>B. OutputStream</p><p>C. A 和B 选项都包含</p><p>D. A 和B 选项都不包含</p><p><strong>正确答案：B 你的答案：C</strong></p><p>flush（）函数强制将缓冲区中的字符流、字节流等输出，原因是如果输出流输出到缓冲区完成后，缓冲区并没有填满，那么缓冲区将会一直等待被填满。所以在关闭输出流之前要调用flush（）</p><h5 id="_22-下列关于java多线程的叙述正确的是" tabindex="-1"><a class="header-anchor" href="#_22-下列关于java多线程的叙述正确的是"><span>22.下列关于JAVA多线程的叙述正确的是（）</span></a></h5><p>A. 调用start()方法和run()都可以启动一个线程</p><p>B. CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程</p><p>C. Callable类的call()方法可以返回值和抛出异常</p><p>D. 新建的线程调用start()方法就能立即进行运行状态</p><p><strong>正确答案：BC</strong></p><p>A. start是开启线程，run是线程的执行体，run是线程执行的入口。</p><p>B. CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。</p><p>C. Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。</p><p>D. start是把线程从new变成了runnable</p><h5 id="_23-java程序内存泄露的最直接表现是" tabindex="-1"><a class="header-anchor" href="#_23-java程序内存泄露的最直接表现是"><span>23.java程序内存泄露的最直接表现是（ ）</span></a></h5><p>A. 频繁FullGc</p><p>B. jvm崩溃</p><p>C. 程序抛内存溢出的Exception</p><p>D. java进程异常消失</p><p><strong>正确答案：C 你的答案：D</strong></p><p>ava是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值 但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大. 最终超出内存界限，抛出OutOfMemoryExpection</p><h5 id="_24-关于java中参数传递的说法-哪个是错误的" tabindex="-1"><a class="header-anchor" href="#_24-关于java中参数传递的说法-哪个是错误的"><span>24.关于Java中参数传递的说法，哪个是错误的？</span></a></h5><p>A. 在方法中，修改一个基础类型的参数不会影响原始参数值</p><p>B. 在方法中，改变一个对象参数的引用不会影响到原始引用</p><p>C. 在方法中，修改一个对象的属性会影响原始对象参数</p><p>D. 在方法中，修改集合和Maps的元素不会影响原始集合参数</p><p><strong>正确答案：D 你的答案：C</strong></p><p>java只有值传递</p><h5 id="_25-下列流当中-属于处理流的是" tabindex="-1"><a class="header-anchor" href="#_25-下列流当中-属于处理流的是"><span>25.下列流当中，属于处理流的是：（）</span></a></h5><p>A. FilelnputStream</p><p>B. lnputStream</p><p>C. DatalnputStream</p><p>D. BufferedlnputStream</p><p><strong>正确答案：CD 你的答案：D</strong></p><p><strong>按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。</strong></p><ul><li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li></ul><ul><li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><p>​ <strong>JAVA常用的节点流：</strong></p><ul><li>文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li><li>字符串 StringReader StringWriter 对字符串进行处理的节点流。</li><li>数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li>管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。</li></ul><p>​ <strong>常用处理流（关闭处理流使用关闭里面的节点流）</strong></p><ul><li><p>缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。</p></li><li><p>转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。</p></li><li><p>数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.</p></li></ul><p>​ <strong>流的关闭顺序</strong></p><ol><li>一般情况下是：先打开的后关闭，后打开的先关闭</li><li>另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b</li><li>可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。</li></ol><h5 id="_26-hashtable-和-hashmap-的区别是" tabindex="-1"><a class="header-anchor" href="#_26-hashtable-和-hashmap-的区别是"><span>26.Hashtable 和 HashMap 的区别是：</span></a></h5><p>A. Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</p><p>B. HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</p><p>C. Hashtable 线程安全的，而 HashMap 是线程不安全的</p><p>D. Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</p><p>E. HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p><strong>正确答案：BCDE 你的答案：E</strong></p><p><strong>Hashtable：</strong></p><ul><li>Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</li><li>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。</li><li>HashTable直接使用对象的hashCode。</li></ul><p><strong>HashMap：</strong></p><ul><li>由数组+链表组成的，基于哈希表的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</li><li>不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</li><li>HashMap重新计算hash值 Hashtable,HashMap,Properties继承关系如下：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Hashtable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Dictionary</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cloneable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.io.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Serializable</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">   public class </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HashMap</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AbstractMap</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cloneable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Serializable</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">     java.lang.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Objecct</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.util.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Dictionary</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.util.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Hashtable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.util.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Properties</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_27-关于java内存区域下列说法不正确的有哪些" tabindex="-1"><a class="header-anchor" href="#_27-关于java内存区域下列说法不正确的有哪些"><span>27.关于Java内存区域下列说法不正确的有哪些</span></a></h5><p>A. 程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器，每个线程都需要一个独立的程序计数器.</p><p>B. Java虚拟机栈描述的是java方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、类信息、动态链接等信息</p><p>C. Java堆是java虚拟机所管理的内存中最大的一块，每个线程都拥有一块内存区域，所有的对象实例以及数组都在这里分配内存。</p><p>D. 方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</p><p><strong>正确答案：BC 你的答案：CD</strong></p><p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（<strong>程序计数器的内存空间是线程私有的</strong>），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 **，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h5 id="_28-下面哪段程序能够正确的实现了gbk编码字节流到utf-8编码字节流的转换" tabindex="-1"><a class="header-anchor" href="#_28-下面哪段程序能够正确的实现了gbk编码字节流到utf-8编码字节流的转换"><span>28.下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：</span></a></h5><p><code>byte[] src,dst;</code></p><p>A. dst=String.fromBytes(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</p><p>B. dst=new String(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</p><p>C. dst=new String(&quot;GBK&quot;，src).getBytes()</p><p>D. dst=String.encode(String.decode(src，&quot;GBK&quot;))，&quot;UTF-8&quot; )</p><p><strong>正确答案：B 你的答案：D</strong></p><p>选B，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串</p><p>String就没有decode和encode方法，坑爹货！</p><h5 id="_29-执行如下程序代码" tabindex="-1"><a class="header-anchor" href="#_29-执行如下程序代码"><span>29.执行如下程序代码</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> chr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 127</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">chr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">sum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> chr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后，sum的值是（）,备注：同时考虑c/c++和Java的情况的话</p><p>A. 72</p><p>B. 99</p><p>C. 328</p><p>D. 327</p><p><strong>正确答案：AC 你的答案：CD</strong></p><p>java中char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p><p>c/c++语言char是一个字节, 会发生溢出, 对127加一发生溢出, 0111 1111 --&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p><h5 id="_30-在web应用程序中-负责将http请求转换为httpservletrequest对象" tabindex="-1"><a class="header-anchor" href="#_30-在web应用程序中-负责将http请求转换为httpservletrequest对象"><span>30.在Web应用程序中，( )负责将HTTP请求转换为HttpServletRequest对象</span></a></h5><p>A. Servlet对象</p><p>B. HTTP服务器</p><p>C. Web容器</p><p>D. JSP网页</p><p><strong>正确答案：C 你的答案：A</strong></p><p>Apache就是一个Http服务器，Tomcat是一个web容器，静态的htmlApache还可以处理，但是动态的需要转发给Tomcat去处理了，比如jsp页面，请求先经由Apache转发给Tomcat再由Tomcat解析请求。所以应该是web容器去解析成request对象</p><h5 id="_31-java8中-下面哪个类用到了解决哈希冲突的开放定址法" tabindex="-1"><a class="header-anchor" href="#_31-java8中-下面哪个类用到了解决哈希冲突的开放定址法"><span>31.java8中，下面哪个类用到了解决哈希冲突的开放定址法</span></a></h5><p>A. LinkedHashSet</p><p>B. HashMap</p><p>C. ThreadLocalMap</p><p>D. TreeMap</p><p><strong>正确答案：C 你的答案：B</strong></p><p>ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突。</p><h5 id="_32-如果希望监听tcp端口9000-服务器端应该怎样创建socket" tabindex="-1"><a class="header-anchor" href="#_32-如果希望监听tcp端口9000-服务器端应该怎样创建socket"><span>32.如果希望监听TCP端口9000，服务器端应该怎样创建socket?</span></a></h5><p>A. new Socket(&quot;localhost&quot;,9000);</p><p>B. new ServerSocket(9000);</p><p>C. new Socket(9000);</p><p>D. new ServerSocket(&quot;localhost&quot;,9000);</p><p><strong>正确答案：B 你的答案：D</strong></p><p>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。</p><p>Socket(InetAddress address , int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。</p><h5 id="_33-关于jdk1-8中java的抽象类、接口-以下描述错误的是" tabindex="-1"><a class="header-anchor" href="#_33-关于jdk1-8中java的抽象类、接口-以下描述错误的是"><span>33.关于JDK1.8中Java的抽象类、接口，以下描述错误的是？</span></a></h5><p>A. 抽象类不一定含有抽象方法，接口中的方法都是抽象方法</p><p>B. 一个类只能继承一个抽象类，但可以实现多个接口；一个接口可以继承多个接口</p><p>C. 抽象类和接口中的方法都没有方法体</p><p>D. 抽象类可以含有私有成员变量，接口不含有私有成员变量</p><p><strong>正确答案：C 你的答案：A</strong></p><ul><li>A 接口中的方法默认修饰符有public abstract。</li><li>B 一个接口可以继承多个接口。 Java里类是单继承的，接口是可以多继承的，用关键字extends。</li><li>C 抽象类中的方法是可以有方法体的。JDK1.8之后，接口中的方法也可以有方法体，用default关键字修饰方法。</li><li>D 接口中的成员变量都是public static final的，一般用作常量。</li></ul><h5 id="_34-下列java代码中的变量a、b、c分别在内存的-存储区存放。" tabindex="-1"><a class="header-anchor" href="#_34-下列java代码中的变量a、b、c分别在内存的-存储区存放。"><span>34.下列Java代码中的变量a、b、c分别在内存的____存储区存放。</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> “aa”</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> methodB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> “bb”;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> “cc”;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>正确答案：堆区、栈区、栈区 你的答案：堆区、堆区、堆区</strong></p><ul><li>堆区：只存放类对象，线程共享；</li><li>方法区：又叫静态存储区，存放class文件和静态数据，线程共享;</li><li>栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;</li></ul><h5 id="_35-下列代码片段中-存在编译错误的语句是" tabindex="-1"><a class="header-anchor" href="#_35-下列代码片段中-存在编译错误的语句是"><span>35.下列代码片段中，存在编译错误的语句是()</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b4</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b5</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(b1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b2)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /*语句1*/</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b6</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b4</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /*语句2*/</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b8</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(b1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b4)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /*语句3*/</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b7</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b5)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /*语句4*/</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(b3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">b6);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A. 语句2</p><p>B. 语句1</p><p>C. 语句3</p><p>D. 语句4</p><p><strong>正确答案：BCD 你的答案：D</strong></p><p>一、关于final的重要知识点;</p><p>1、final关键字可以用于成员变量、本地变量、方法以及类。</p><p>2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</p><p>3、 你不能够对final变量再次赋值。</p><p>4、 本地变量必须在声明时赋值。</p><p>5、 在匿名类中所有变量都必须是final变量。</p><p>6、 final方法不能被重写。</p><p>7、 final类不能被继承。</p><p>8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</p><p>二、数据类型转换</p><p>当使用 +、-、*、/、%、运算操作是，遵循如下规则：</p><p>只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类型，如果两个操作数中有一个是float类型的，另一个将会被转换为float类型，并且结果也是float类型，如果两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类型，否则（操作数为：byte、short、int 、char），两个数都会被转换成int类型，并且结果也是int类型。</p><p>语句 1 :（b1 + b2） 被转换为int类型 但是 b3仍为 byte ，所以出错 要么将b3转化为int 要么将（b1 + b2） 强制转换为byte类型。所以语句1错误。</p><p>语句 2：b4 、b5被声明final 所以类型是不会转换， 计算结果任然是byte ，所以 语句2正确。</p><p>语句 3：(b1 + b4) 结果仍然转换成int 所以语句 3 错误。</p><p>语句 4 : (b2 + b5) 结果仍然转换为int ， 所以语句4错误。</p>`,326)]))}const k=i(p,[["render",e],["__file","Java刷题错题集合.html.vue"]]),d=JSON.parse('{"path":"/posts/Java%E5%88%B7%E9%A2%98%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88.html","title":"Java刷题错题集合","lang":"zh-CN","frontmatter":{"title":"Java刷题错题集合","tags":"错题","categories":"Java","date":"2024-03-03T15:41:29.000Z","description":"1. 下面论述正确的是（）？ A. 如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值 B. 如果a,b的hashcode相同，那么a.equals(b)必须返回true C. 对于一个类，其所有对象的hashcode必须不同 D. 如果a.equals(b)返回true，那么a,b两个对象的hashcod...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://xupan.fun/posts/Java%E5%88%B7%E9%A2%98%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"苏禾的博客"}],["meta",{"property":"og:title","content":"Java刷题错题集合"}],["meta",{"property":"og:description","content":"1. 下面论述正确的是（）？ A. 如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值 B. 如果a,b的hashcode相同，那么a.equals(b)必须返回true C. 对于一个类，其所有对象的hashcode必须不同 D. 如果a.equals(b)返回true，那么a,b两个对象的hashcod..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s21.ax1x.com/2024/05/27/pk1VlYF.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2024-03-03T15:41:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java刷题错题集合\\",\\"image\\":[\\"https://s21.ax1x.com/2024/05/27/pk1VlYF.png\\",\\"https://img2.baidu.com/it/u=650402853,3705164043&fm=253&fmt=auto&app=138&f=PNG?w=1407&h=500\\"],\\"datePublished\\":\\"2024-03-03T15:41:29.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"苏禾\\",\\"url\\":\\"https://xupan.fun\\",\\"email\\":\\"xp0920ww@163.com\\"}]}"]]},"headers":[],"readingTime":{"minutes":26.77,"words":8032},"filePathRelative":"posts/Java刷题错题集合.md","localizedDate":"2024年3月3日","excerpt":"<h5>1. 下面论述正确的是（）？</h5>\\n<p>A. 如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值</p>\\n<p>B. 如果a,b的hashcode相同，那么a.equals(b)必须返回true</p>\\n<p>C. 对于一个类，其所有对象的hashcode必须不同</p>\\n<p>D. 如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同</p>\\n<p><strong>正确答案：D\\t你的答案：B</strong></p>\\n<p>hashCode方法本质就是一个哈希函数，这是Object类的作者说明的。Object类的作者在注释的最后一段的括号中写道：将对象的地址值映射为integer类型的哈希值。但hashCode()并不完全可靠的，有时候不同的对象他们生成的hashcode也会一样，因此hashCode()只能说是大部分时候可靠。</p>","autoDesc":true}');export{k as comp,d as data};
